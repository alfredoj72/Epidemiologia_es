[{"path":"index.html","id":"section","chapter":"","heading":"","text":"","code":""},{"path":"index.html","id":"r-para-epidemiología-aplicada-y-salud-pública","chapter":"","heading":"R para epidemiología aplicada y salud pública","text":"Utilización: Este manual ha sido utilizado más de 1 millón de veces por 300.000 personas en todo el mundo.Objetivo: Servir como breve guía de referencia para escribir código en R (en línea y versión sin conexión) con ejemplos detallados que aborden problemas epidemiológicos.¿Estás empezando con R? Prueba nuestros tutoriales interactivos gratuitos o el curso de introducción sincrónico, utilizado por los CDC de EE.UU., la OMS, y más de 75 agencias de salud y programas de formación de Epi de campo.\nIdiomas: Inglés (English), Vietnamita (Tiếng Việt), Turco (Türkçe), Japonés (日本)\n \nEscrito y traducido por profesionales de la epidemiología, para profesionales de la epidemiologíaSomos epi’s de campo de todo el mundo, escribiendo en nuestro tiempo libre para ofrecer este recurso la comunidad. Tu apoyo y comentarios son muy bienvenidos:Envía un email contact@appliedepi.org, un tweet @appliedepi, o en LinkedInEnvía problemas nuestro Repositorio Github","code":""},{"path":"index.html","id":"how-to-use-this-handbook","chapter":"","heading":"Cómo utilizar este manual","text":"Navega por las páginas del índice o utiliza el cuadro de búsquedaClica en los iconos “Copy” para copiar el códigoPuedes seguir paso paso las lecciones utilizando nuestros [datos de ejemplo][Download handbook data]Versión sin conexiónConsulta las instrucciones en la página de Descargar el Manual y los datos.","code":""},{"path":"index.html","id":"acknowledgements","chapter":"","heading":"Agradecimientos","text":"Este manual ha sido elaborado mediante la colaboración de profesionales de la epidemiología de todo el mundo, basándonos en nuestra experiencia en organismos sanitarios locales, estatales, provinciales y nacionales, la Organización Mundial de la Salud (OMS), Médicos Sin Fronteras (MSF), sistemas hospitalarios e instituciones académicas.Este manual es un producto aprobado por ninguna organización específica. Aunque nos esforzamos por ser precisos, ofrecemos ninguna garantía sobre el contenido de este libro.","code":""},{"path":"index.html","id":"colaboradores","chapter":"","heading":"Colaboradores","text":"Redactor jefe: Neale BatraEquipo central del proyecto: Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay CampbellAutores: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen LinRevisores: Pat Keating, Annick Lenglet, Margot Charette, Danielly Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao MuiangaEquipo de traducción al español: Juan Carlos Fernández-Merino, Juan Francisco Monteagudo, Ximena Tolosa, Luis Hernando Aguilar Ramirez, Ignacio Castro Aguirre, Esther Kukielka, Cristina Torró, Ana Fernández-Ayuso.Illustraciones: Calder Fong","code":""},{"path":"index.html","id":"financiación-y-apoyo","chapter":"","heading":"Financiación y apoyo","text":"Este libro ha sido principalmente un esfuerzo voluntario que ha requerido miles de horas de trabajo.\nEl manual recibió apoyo financiaciero de TEPHINET, la red mundial de Programas de Formación en Epidemiología de Campo (FETP) través de una subvención para el desarrollo de capacidades de emergencia COVID-19.La Red de Antiguos Alumnos de (EAN) proporcionó apoyo administrativo, con un agradecimiento especial Annika Wendland. EPIET es el Programa Europeo de Formación en Epidemiología de Intervención.Un agradecimiento especial Médicos Sin Fronteras (MSF) Centro Operativo de Ámsterdam (OCA) por su apoyo durante la elaboración de este manual.Esta publicación fue respaldada por el Acuerdo de Cooperación número NU2GGH001873, financiado por los Centros para el Control y la Prevención de Enfermedades través de TEPHINET, un programa de Task Force Global Health. Su contenido es responsabilidad exclusiva de los autores y representa necesariamente las opiniones oficiales de los Centros para el Control y la Prevención de Enfermedades, el Departamento de Salud y Servicios Humanos, Task Force Global Health, Inc. o TEPHINET.","code":""},{"path":"index.html","id":"inspiración","chapter":"","heading":"Inspiración","text":"Hay multitud de tutoriales y viñetas que aportaron conocimientos para el desarrollo del contenido del manual y se acreditan en sus respectivas páginas.De manera más general, las siguientes fuentes han servido de inspiración para este manual:El proyecto “R4Epis” (una colaboración entre MSF y RECON)R Epidemics Consortium (RECON)El libro R Data Science (R4DS), en español en este enlacebookdown: Creación de libros y documentos técnicos con R MarkdownNetlify alberga este sitio web","code":""},{"path":"index.html","id":"terms-of-use-and-contribution","chapter":"","heading":"Condiciones de uso y contribución","text":"","code":""},{"path":"index.html","id":"licencia","chapter":"","heading":"Licencia","text":"Esta obra está bajo una Licencia Internacional Creative Commons Attribution-NonCommercial-ShareAlike 4.0.Los cursos académicos y los programas de formación en epidemiología pueden utilizar este manual con sus estudiantes - por favor díganos. Si tienes preguntas sobre el uso que se le va dar, envía un correo electrónico contact@appliedepi.org.","code":""},{"path":"index.html","id":"cita-sugerida","chapter":"","heading":"Cita sugerida","text":"Batra, Neale, et al. Manual de R para Epidemiología. 2021. ","code":""},{"path":"index.html","id":"contribución","chapter":"","heading":"Contribución","text":"Si quieres hacer una contribución de contenido, por favor, ponte en contacto con nosotros primero través de Github o por correo electrónico. Estamos implementando un calendario de actualizaciones y estamos creando una guía para colaboradores.Ten en cuenta que el proyecto epiRhandbook se publica con un Código de Conducta del Colaborador . Al contribuir este proyecto, te comprometes respetar sus términos.","code":""},{"path":"writing-functions-1.html","id":"writing-functions-1","chapter":"1 Escribir funciones","heading":"1 Escribir funciones","text":"","code":""},{"path":"writing-functions-1.html","id":"preparation-37","chapter":"1 Escribir funciones","heading":"1.1 Preparación","text":"","code":""},{"path":"writing-functions-1.html","id":"cargar-paquetes","chapter":"1 Escribir funciones","heading":"Cargar paquetes","text":"Este trozo de código muestra la carga de los paquetes necesarios para los análisis. En este manual destacamos p_load() de pacman, que instala el paquete si es necesario y lo carga para su uso. También puedes cargar los paquetes instalados con library() de R base. Consulta la página fundamentos de R para obtener más información sobre los paquetes de R.","code":""},{"path":"writing-functions-1.html","id":"importar-datos","chapter":"1 Escribir funciones","heading":"Importar datos","text":"Importamos los datos de casos de una epidemia de ébola simulada. Si deseas descargar los datos para seguirlos paso paso, consulta las instrucciones en la página [Descargar libro y datos]. Los datos se importan mediante la función import() del paquete rio. Consulta la página sobre importación y exportación para conocer las distintas formas de importar datos.También utilizaremos en la última parte de esta página algunos datos sobre la gripe H7N9 de 2013.","code":""},{"path":"writing-functions-1.html","id":"functions-2","chapter":"1 Escribir funciones","heading":"1.2 Funciones","text":"Las funciones son útiles en la programación, ya que permiten hacer códigos más fáciles de entender, de alguna manera más cortos y menos propensos errores (dado que hay errores en la propia función).Si llegado hasta este manual, significa que te encontrado con un sinfín de funciones ya que en R, cada operación es una llamada una función +, , , [, $, { …. Por ejemplo, x + y es lo mismo que'+'(x, y)R es uno de los lenguajes que más posibilidades ofrece para trabajar con funciones y da suficientes herramientas al usuario para escribirlas fácilmente. debemos pensar en las funciones como algo fijo en la cima o al final de la cadena de programación, R ofrece la posibilidad de utilizarlas como si fueran vectores e incluso utilizarlas dentro de otras funciones, listas…Existen muchos recursos muy avanzados sobre programación funcional y aquí sólo daremos una visión para ayudarte empezar con la programación de funciones con breves ejemplos prácticos. Te animamos visitar los enlaces de las referencias para leer más sobre el tema.","code":""},{"path":"writing-functions-1.html","id":"why-would-you-use-a-function","chapter":"1 Escribir funciones","heading":"1.3 ¿Por qué utilizar una función?","text":"Antes de responder esta pregunta, es importante tener en cuenta que ya tenido consejos para llegar escribir tus primeras funciones R en la página sobre Iteración, bucles y listas de este manual. De hecho, el uso de “/else” y bucles suele ser una parte fundamental de muchas de nuestras funciones, ya que ayudan fácilmente ampliar la aplicación de nuestro código permitiendo múltiples condiciones o iterar códigos para repetir tareas.¿Estoy repitiendo varias veces el mismo bloque de código para aplicarlo una variable o dato diferente?¿Estoy repitiendo varias veces el mismo bloque de código para aplicarlo una variable o dato diferente?Deshacerse de él, ¿acortará sustancialmente mi código general y hará que se ejecute más rápido?Deshacerse de él, ¿acortará sustancialmente mi código general y hará que se ejecute más rápido?¿Es posible que el código que escrito se utilice de nuevo pero con un valor diferente en muchos lugares del código?¿Es posible que el código que escrito se utilice de nuevo pero con un valor diferente en muchos lugares del código?Si la respuesta una de las preguntas anteriores es “SÍ”, es probable que tenga que escribir una función.","code":""},{"path":"writing-functions-1.html","id":"how-does-r-build-functions","chapter":"1 Escribir funciones","heading":"1.4 ¿Cómo construye R las funciones?","text":"Las funciones en R tienen tres componentes principales:las formals() que es la lista de argumentos que controla cómo podemos llamar la funciónlas formals() que es la lista de argumentos que controla cómo podemos llamar la funciónel body() que es el código dentro de la función, es decir, dentro de los paréntesis o después del paréntesis, dependiendo de cómo lo escribamosel body() que es el código dentro de la función, es decir, dentro de los paréntesis o después del paréntesis, dependiendo de cómo lo escribamosy,el environment() que ayudará localizar las variables de la función y determina cómo encuentra la función el valor.Una vez que hayas creado tu función, puedes verificar cada uno de estos componentes llamando la función asociada.","code":""},{"path":"writing-functions-1.html","id":"basic-syntax-and-structure","chapter":"1 Escribir funciones","heading":"1.5 Sintaxis y estructura básica","text":"Una función tendrá que ser nombrada adecuadamente para que su trabajo sea fácilmente comprensible tan pronto como leamos su nombre. En realidad, este es el caso de la mayoría de la arquitectura básica de R. Funciones como mean(), print(), summary() tienen nombres muy sencillosUna función tendrá que ser nombrada adecuadamente para que su trabajo sea fácilmente comprensible tan pronto como leamos su nombre. En realidad, este es el caso de la mayoría de la arquitectura básica de R. Funciones como mean(), print(), summary() tienen nombres muy sencillosUna función necesitará argumentos, como los datos sobre los que trabajar y otros objetos que pueden ser valores estáticos entre otras opcionesUna función necesitará argumentos, como los datos sobre los que trabajar y otros objetos que pueden ser valores estáticos entre otras opcionesY finalmente una función producirá una salida basada en su tarea principal y en los argumentos que se le han dado. Normalmente utilizaremos las funciones incorporadas como print(), return()… para producir la salida. La salida puede ser un valor lógico, un número, un carácter, un dataframe… en definitiva cualquier tipo de objeto de R.Y finalmente una función producirá una salida basada en su tarea principal y en los argumentos que se le han dado. Normalmente utilizaremos las funciones incorporadas como print(), return()… para producir la salida. La salida puede ser un valor lógico, un número, un carácter, un dataframe… en definitiva cualquier tipo de objeto de R.Básicamente se trata de la composición de una función:Podemos crear nuestra primera función que se llamará contain_covid19().continuación, podemos verificar los componentes de nuestra función recién creada.Ahora vamos probar nuestra función. Para llamar nuestra función escrita, la usas como usas todas las funciones de R, es decir, escribiendo el nombre de la función y añadiendo los argumentos necesarios.Podemos volver escribir el nombre de cada argumento por precaución. Pero sin especificarlos, el código debería funcionar ya que R tiene en memoria la posición de cada argumento. Así que mientras pongas los valores de los argumentos en el orden correcto, puedes omitir escribir los nombres de los argumentos al llamar las funciones.continuación, veamos qué ocurre si uno de los valores es \"\" o \"yes\".Si proporcionamos un argumento que es reconocido, se producirá un error:Error en contain_covid19(barrier_gest = \"sometimes\", wear_mask = \"yes\", : se pudo encontrar la función \"contain_covid19\"NOTA: Algunas funciones (la mayoría de las veces muy cortas y sencillas) pueden necesitar un nombre y pueden ser utilizadas directamente en una línea de código o dentro de otra función para realizar una tarea rápida. Se llaman funciones anónimas.Por ejemplo, continuación se muestra una primera función anónima que mantiene sólo las variables de carácter de los datos.continuación, otra función que selecciona una de cada dos observaciones de nuestro conjunto de datos (puede ser relevante cuando tenemos datos longitudinales con muchos registros por paciente, por ejemplo, después de haber ordenado por fecha o visita). En este caso, la función adecuada que se escribe fuera de dplyr sería function (x) (x%2 == 0) para aplicarla al vector que contiene todos los números de fila.Un posible código para la misma tarea sería:PRECAUCIÓN: Aunque es cierto que el uso de funciones puede ayudarnos con nuestro código, puede llevar mucho tiempo escribir algunas funciones o arreglar una si ha sido pensada fondo, escrita adecuadamente y está devolviendo errores como resultado. Por esta razón, menudo se recomienda escribir primero el código en R, asegurarse de que hace lo que pretendemos, y luego transformarlo en una función con sus tres componentes principales, como se ha indicado anteriormente.","code":"\nfunction_name <- function(argument_1, argument_2, argument_3){\n  \n           function_task\n  \n           return(output)\n}\ncontain_covid19 <- function(barrier_gest, wear_mask, get_vaccine){\n  \n                            if(barrier_gest == \"yes\" & wear_mask == \"yes\" & get_vaccine == \"yes\" ) \n       \n                            return(\"success\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\nformals(contain_covid19)## $barrier_gest\n## \n## \n## $wear_mask\n## \n## \n## $get_vaccine\nbody(contain_covid19)## {\n##     if (barrier_gest == \"yes\" & wear_mask == \"yes\" & get_vaccine == \n##         \"yes\") \n##         return(\"success\")\n##     else (\"please make sure all are yes, this pandemic has to end!\")\n## }\nenvironment(contain_covid19)## <environment: R_GlobalEnv>\ncontain_covid19(barrier_gest = \"yes\", wear_mask = \"yes\", get_vaccine = \"yes\")## [1] \"success\"\ncontain_covid19(\"yes\", \"yes\", \"yes\")## [1] \"success\"\ncontain_covid19(barrier_gest = \"yes\", wear_mask = \"yes\", get_vaccine = \"no\")## [1] \"please make sure all are yes, this pandemic has to end!\"\ncontain_covid19(barrier_gest = \"sometimes\", wear_mask = \"yes\", get_vaccine = \"no\")\nlinelist %>% \n  dplyr::slice_head(n=10) %>%  #equivalente a la función de R base \"head\" que retorna las n primeras observaciones de un conjunto de datos.\n  select(function(x) is.character(x)) \nlinelist %>%   \n   slice_head(n=20) %>% \n   tibble::rownames_to_column() %>% # agregue índices de cada obs como rownames para ver claramente la selección final\n   filter(row_number() %%2 == 0)\nlinelist_firstobs <- head(linelist, 20)\n\nlinelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),]"},{"path":"writing-functions-1.html","id":"examples-2","chapter":"1 Escribir funciones","heading":"1.6 Ejemplos","text":"","code":""},{"path":"writing-functions-1.html","id":"devuelve-tablas-de-proporciones-para-varias-columnas","chapter":"1 Escribir funciones","heading":"Devuelve tablas de proporciones para varias columnas","text":"Sí, ya disponemos de bonitas funciones en muchos paquetes que permiten resumir la información de una manera muy fácil y agradable. Pero aún así intentaremos hacer las nuestras, en nuestros primeros pasos para acostumbrarnos escribir funciones.En este ejemplo queremos mostrar cómo la escritura de una función simple te evitaría copiar y pegar el mismo código varias veces.CONSEJO: Como se ha indicado anteriormente, es muy importante comentar las funciones como se haría en la programación general. Ten en cuenta que el objetivo de una función es hacer un código fácil de leer, más corto y más eficiente. Entonces uno debería ser capaz de entender lo que hace la función con sólo leer su nombre y debería tener más detalles leyendo los comentarios.Una segunda opción es utilizar esta función en otra través de un bucle para hacer el proceso la vez:Una forma más sencilla podría ser utilizar la base R “apply” en lugar de un “bucle ” como se expresa continuación:CONSEJO: R se define menudo como un lenguaje de programación funcional y casi siempre que ejecutas una línea de código estás utilizando algunas funciones incorporadas. Un buen hábito para sentirse más cómodo con la escritura de funciones es echar menudo un vistazo interno cómo están construidas las funciones básicas que utiliza diario. El atajo para hacerlo es seleccionar el nombre de la función y luego clicar en Ctrl+F2 o fn+F2 o Cmd+F2 (dependiendo de tu ordenador).","code":"\nproptab_multiple <- function(my_data, var_to_tab){\n  \n  #imprime el nombre de cada variable de interés antes de realizar la tabulación\n  print(var_to_tab)\n\n  with(my_data,\n       rbind( #enlazar por filas los resultados de las siguientes dos funciones \n        #tabular la variable de interés: da solo números\n          table(my_data[[var_to_tab]], useNA = \"no\"),\n          #calcular la proporción de cada variable de interés y redondear el valor a 2 decimales\n         round(prop.table(table(my_data[[var_to_tab]]))*100,2)\n         )\n       )\n}\n\n\nproptab_multiple(linelist, \"gender\")## [1] \"gender\"##            f       m\n## [1,] 2807.00 2803.00\n## [2,]   50.04   49.96\nproptab_multiple(linelist, \"age_cat\")## [1] \"age_cat\"##          0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n## [1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n## [2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\nproptab_multiple(linelist, \"outcome\")## [1] \"outcome\"##        Death Recover\n## [1,] 2582.00 1983.00\n## [2,]   56.56   43.44\nfor(var_to_tab in c(\"gender\",\"age_cat\",  \"outcome\")){\n  \n  print(proptab_multiple(linelist, var_to_tab))\n  \n}## [1] \"gender\"\n##            f       m\n## [1,] 2807.00 2803.00\n## [2,]   50.04   49.96\n## [1] \"age_cat\"\n##          0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n## [1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n## [2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\n## [1] \"outcome\"\n##        Death Recover\n## [1,] 2582.00 1983.00\n## [2,]   56.56   43.44"},{"path":"writing-functions-1.html","id":"using-purrr-writing-functions-that-can-be-iteratively-applied","chapter":"1 Escribir funciones","heading":"1.7 Uso de purrr: escribir funciones que se pueden aplicar de forma iterativa","text":"","code":""},{"path":"writing-functions-1.html","id":"modificar-el-tipo-de-múltiples-columnas-en-unos-datos","chapter":"1 Escribir funciones","heading":"Modificar el tipo de múltiples columnas en unos datos","text":"Digamos que muchas variables de carácter en los datos originales de linelist necesitan ser cambiadas “factor” para propósitos de análisis y trazado. En lugar de repetir el paso varias veces, podemos utilizar simplemente lapply() para realizar la transformación de todas las variables afectadas en una sola línea de código.PRECAUCIÓN: lapply() devuelve una lista, por lo que su uso puede requerir una modificación adicional como último paso.El mismo paso puede realizarse utilizando la función map_if() del paquete purrr","code":"\nlinelist_factor2 <- linelist %>%\n  purrr::map_if(is.character, as.factor)\n\n\nlinelist_factor2 %>%\n        glimpse()## List of 30\n##  $ case_id             : Factor w/ 5888 levels \"00031d\",\"00086d\",..: 2134 3022 396 4203 3084 4347 179 1241 5594 430 ...\n##  $ generation          : num [1:5888] 4 4 2 3 3 3 4 4 4 4 ...\n##  $ date_infection      : Date[1:5888], format: \"2014-05-08\" NA NA \"2014-05-04\" ...\n##  $ date_onset          : Date[1:5888], format: \"2014-05-13\" \"2014-05-13\" \"2014-05-16\" \"2014-05-18\" ...\n##  $ date_hospitalisation: Date[1:5888], format: \"2014-05-15\" \"2014-05-14\" \"2014-05-18\" \"2014-05-20\" ...\n##  $ date_outcome        : Date[1:5888], format: NA \"2014-05-18\" \"2014-05-30\" NA ...\n##  $ outcome             : Factor w/ 2 levels \"Death\",\"Recover\": NA 2 2 NA 2 2 2 1 2 1 ...\n##  $ gender              : Factor w/ 2 levels \"f\",\"m\": 2 1 2 1 2 1 1 1 2 1 ...\n##  $ age                 : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n##  $ age_unit            : Factor w/ 2 levels \"months\",\"years\": 2 2 2 2 2 2 2 2 2 2 ...\n##  $ age_years           : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n##  $ age_cat             : Factor w/ 8 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 7 4 1 4 4 1 7 5 ...\n##  $ age_cat5            : Factor w/ 18 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 12 4 1 4 4 1 13 6 ...\n##  $ hospital            : Factor w/ 6 levels \"Central Hospital\",..: 4 3 6 5 2 5 3 3 3 3 ...\n##  $ lon                 : num [1:5888] -13.2 -13.2 -13.2 -13.2 -13.2 ...\n##  $ lat                 : num [1:5888] 8.47 8.45 8.46 8.48 8.46 ...\n##  $ infector            : Factor w/ 2697 levels \"00031d\",\"002e6c\",..: 2594 NA NA 2635 180 1799 1407 195 NA NA ...\n##  $ source              : Factor w/ 2 levels \"funeral\",\"other\": 2 NA NA 2 2 2 2 2 NA NA ...\n##  $ wt_kg               : num [1:5888] 27 25 91 41 36 56 47 0 86 69 ...\n##  $ ht_cm               : num [1:5888] 48 59 238 135 71 116 87 11 226 174 ...\n##  $ ct_blood            : num [1:5888] 22 22 21 23 23 21 21 22 22 22 ...\n##  $ fever               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n##  $ chills              : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n##  $ cough               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 2 ...\n##  $ aches               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n##  $ vomit               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 1 ...\n##  $ temp                : num [1:5888] 36.8 36.9 36.9 36.8 36.9 37.6 37.3 37 36.4 35.9 ...\n##  $ time_admission      : Factor w/ 1072 levels \"00:10\",\"00:29\",..: NA 308 746 415 514 589 609 297 409 387 ...\n##  $ bmi                 : num [1:5888] 117.2 71.8 16.1 22.5 71.4 ...\n##  $ days_onset_hosp     : num [1:5888] 2 1 2 2 1 1 2 1 1 2 ..."},{"path":"writing-functions-1.html","id":"elaborar-de-forma-iterativa-gráficos-para-diferentes-niveles-de-una-variable","chapter":"1 Escribir funciones","heading":"Elaborar de forma iterativa gráficos para diferentes niveles de una variable","text":"Produciremos aquí un gráfico circular para ver la distribución del resultado de los pacientes en China durante el brote de H7N9 para cada provincia. En lugar de repetir el código para cada una de ellas, nos limitaremos aplicar una función que crearemos.","code":"\n#precisar opciones para el uso de highchart\noptions(highcharter.theme =   highcharter::hc_theme_smpl(tooltip = list(valueDecimals = 2)))\n\n\n#Cree una función llamada \"chart_outcome_province\" que tome como argumento el conjunto de datos y el nombre de la provincia para la cual plotear la distribución del resultado.\n\nchart_outcome_province <- function(data_used, prov){\n  \n  tab_prov <- data_used %>% \n    filter(province == prov,\n           !is.na(outcome))%>% \n    group_by(outcome) %>% \n    count() %>%\n    adorn_totals(where = \"row\") %>% \n    adorn_percentages(denominator = \"col\", )%>%\n    mutate(\n        perc_outcome= round(n*100,2))\n  \n  \n  tab_prov %>%\n    filter(outcome != \"Total\") %>% \n  highcharter::hchart(\n    \"pie\", hcaes(x = outcome, y = perc_outcome),\n    name = paste0(\"Distibution of the outcome in:\", prov)\n    )\n  \n}\n\nchart_outcome_province(flu_china, \"Shanghai\")\nchart_outcome_province(flu_china,\"Zhejiang\")\nchart_outcome_province(flu_china,\"Jiangsu\")"},{"path":"writing-functions-1.html","id":"producir-iterativamente-tablas-para-diferentes-niveles-de-una-variable","chapter":"1 Escribir funciones","heading":"Producir iterativamente tablas para diferentes niveles de una variable","text":"Aquí crearemos tres indicadores para resumirlos en una tabla y nos gustaría elaborar esta tabla para cada una de las provincias. Nuestros indicadores son el retraso entre el inicio y la hospitalización, el porcentaje de recuperación y la edad media de los casos.Indicateurs pour la province de: ShanghaiIndicateursEstimationMean delay onset-hosp4.0Percentage recovery46.7Median age cases67.0Indicateurs pour la province de: JiangsuIndicateursEstimationMean delay onset-hosp6.0Percentage recovery71.4Median age cases55.0","code":"\nindic_1 <- flu_china %>% \n  group_by(province) %>% \n  mutate(\n    date_hosp= strptime(date_of_hospitalisation, format = \"%m/%d/%Y\"),\n    date_ons= strptime(date_of_onset, format = \"%m/%d/%Y\"), \n    delay_onset_hosp= as.numeric(date_hosp - date_ons)/86400,\n    mean_delay_onset_hosp = round(mean(delay_onset_hosp, na.rm=TRUE ), 0)) %>%\n  select(province, mean_delay_onset_hosp)  %>% \n  distinct()\n     \n\nindic_2 <-  flu_china %>% \n            filter(!is.na(outcome)) %>% \n            group_by(province, outcome) %>% \n            count() %>%\n            pivot_wider(names_from = outcome, values_from = n) %>% \n    adorn_totals(where = \"col\") %>% \n    mutate(\n        perc_recovery= round((Recover/Total)*100,2))%>% \n  select(province, perc_recovery)\n    \n    \n    \nindic_3 <-  flu_china %>% \n            group_by(province) %>% \n            mutate(\n                    median_age_cases = median(as.numeric(age), na.rm = TRUE)\n            ) %>% \n  select(province, median_age_cases)  %>% \n  distinct()## Warning in median(as.numeric(age), na.rm = TRUE): NAs introduced by coercion\n#unir los indicadores de los tres conjuntos de datos\n\ntable_indic_all <- indic_1 %>% \n  dplyr::left_join(indic_2, by = \"province\") %>% \n        left_join(indic_3, by = \"province\")\n\n\n#imprimir los indicadores en una flextable\n\n\nprint_indic_prov <-  function(table_used, prov){\n  \n  #first transform a bit the dataframe for printing ease\n  indic_prov <- table_used %>%\n    filter(province==prov) %>%\n    pivot_longer(names_to = \"Indicateurs\", cols = 2:4) %>% \n   mutate( indic_label = factor(Indicateurs,\n   levels= c(\"mean_delay_onset_hosp\",\"perc_recovery\",\"median_age_cases\"),\n   labels=c(\"Mean delay onset-hosp\",\"Percentage of recovery\", \"Median age of the cases\"))\n   ) %>% \n    ungroup(province) %>% \n    select(indic_label, value)\n  \n\n    tab_print <- flextable(indic_prov)  %>%\n    theme_vanilla() %>% \n    flextable::fontsize(part = \"body\", size = 10) \n    \n    \n     tab_print <- tab_print %>% \n                  autofit()   %>%\n                  set_header_labels( \n                indic_label= \"Indicateurs\", value= \"Estimation\") %>%\n    flextable::bg( bg = \"darkblue\", part = \"header\") %>%\n    flextable::bold(part = \"header\") %>%\n    flextable::color(color = \"white\", part = \"header\") %>% \n    add_header_lines(values = paste0(\"Indicateurs pour la province de: \", prov)) %>% \nbold(part = \"header\")\n \n tab_print <- set_formatter_type(tab_print,\n   fmt_double = \"%.2f\",\n   na_str = \"-\")\n\ntab_print \n    \n}\n\n\n\n\nprint_indic_prov(table_indic_all, \"Shanghai\")\nprint_indic_prov(table_indic_all, \"Jiangsu\")"},{"path":"writing-functions-1.html","id":"tips-and-best-practices-for-well-functioning-functions","chapter":"1 Escribir funciones","heading":"1.8 Consejos y buens prácticas para el buen funcionamiento de las funciones","text":"La programación funcional está pensada para aliviar el código y facilitar su lectura. Podría producir lo contrario. Los siguientes consejos le ayudarán tener un código limpio y fácil de leer.","code":""},{"path":"writing-functions-1.html","id":"nombres-y-sintaxis","chapter":"1 Escribir funciones","heading":"Nombres y sintaxis","text":"Evitar el uso de caracteres que podrían haber sido fácilmente tomados por otras funciones ya existentes en su entornoEvitar el uso de caracteres que podrían haber sido fácilmente tomados por otras funciones ya existentes en su entornoSe recomienda que el nombre de la función sea corto y sencillo de entender para otro lectorSe recomienda que el nombre de la función sea corto y sencillo de entender para otro lectorEs preferible utilizar verbos como nombre de la función y sustantivos para los nombres de los argumentos.Es preferible utilizar verbos como nombre de la función y sustantivos para los nombres de los argumentos.","code":""},{"path":"writing-functions-1.html","id":"nombres-de-columnas-y-evaluación-ordenada","chapter":"1 Escribir funciones","heading":"Nombres de columnas y evaluación ordenada","text":"Si quiere saber cómo referenciar nombres de columnas que se proporcionan su código como argumentos, lea esta guía de programación de tidyverse. Entre los temas tratados están la evaluación ordenada y el uso del abrazo con {{ }} “llaves dobles”Por ejemplo, aquí hay un esqueleto rápido de código de plantilla del tutorial de la página mencionada anteriormente:","code":"\nvar_summary <- function(data, var) {\n  data %>%\n    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))\n}\nmtcars %>% \n  group_by(cyl) %>% \n  var_summary(mpg)"},{"path":"writing-functions-1.html","id":"pruebas-y-tratamiento-de-errores","chapter":"1 Escribir funciones","heading":"Pruebas y tratamiento de errores","text":"Cuanto más complicada sea la tarea de una función, mayor será la posibilidad de errores. Por lo tanto, veces es necesario añadir alguna verificación dentro de la función para ayudar entender rápidamente de dónde proviene el error y encontrar una manera de solucionarlo.Puede ser más que recomendable introducir una comprobación sobre la ausencia de un argumento utilizando missing(argumento). Esta simple comprobación puede devolver el valor “TRUE” o “FALSE”.Utiliza stop() para errores más detectables.Como vemos cuando ejecutamos la mayoría de las funciones incorporadas, hay mensajes y advertencias que pueden aparecer en ciertas condiciones. Podemos integrarlos en nuestras funciones escritas utilizando las funciones message() y warning().Como vemos cuando ejecutamos la mayoría de las funciones incorporadas, hay mensajes y advertencias que pueden aparecer en ciertas condiciones. Podemos integrarlos en nuestras funciones escritas utilizando las funciones message() y warning().También podemos manejar los errores usando safely() que toma una función como argumento y la ejecuta de forma segura. De hecho, la función se ejecutará sin detenerse si encuentra un error. safely() devuelve como salida una lista con dos objetos que son los resultados y el error que se ha “saltado”.También podemos manejar los errores usando safely() que toma una función como argumento y la ejecuta de forma segura. De hecho, la función se ejecutará sin detenerse si encuentra un error. safely() devuelve como salida una lista con dos objetos que son los resultados y el error que se ha “saltado”.Podemos verificarlo ejecutando primero la mean() como función, y luego ejecutarla con safely().Como se ha dicho anteriormente, comentar bien nuestros códigos ya es una buena forma de tener documentación en nuestro trabajo.","code":"\ncontain_covid19_missing <- function(barrier_gest, wear_mask, get_vaccine){\n  \n  if (missing(barrier_gest)) (print(\"please provide arg1\"))\n  if (missing(wear_mask)) print(\"please provide arg2\")\n  if (missing(get_vaccine)) print(\"please provide arg3\")\n\n\n  if (!barrier_gest == \"yes\" | wear_mask ==\"yes\" | get_vaccine == \"yes\" ) \n       \n       return (\"you can do better\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\n\ncontain_covid19_missing(get_vaccine = \"yes\")## [1] \"please provide arg1\"\n## [1] \"please provide arg2\"## Error in contain_covid19_missing(get_vaccine = \"yes\"): argument \"barrier_gest\" is missing, with no default\ncontain_covid19_stop <- function(barrier_gest, wear_mask, get_vaccine){\n  \n  if(!is.character(barrier_gest)) (stop(\"arg1 should be a character, please enter the value with `yes`, `no` or `sometimes\"))\n  \n  if (barrier_gest == \"yes\" & wear_mask ==\"yes\" & get_vaccine == \"yes\" ) \n       \n       return (\"success\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\n\ncontain_covid19_stop(barrier_gest=1, wear_mask=\"yes\", get_vaccine = \"no\")## Error in contain_covid19_stop(barrier_gest = 1, wear_mask = \"yes\", get_vaccine = \"no\"): arg1 should be a character, please enter the value with `yes`, `no` or `sometimes\nmap(linelist, mean)## $case_id\n## [1] NA\n## \n## $generation\n## [1] 16.56165\n## \n## $date_infection\n## [1] NA\n## \n## $date_onset\n## [1] NA\n## \n## $date_hospitalisation\n## [1] \"2014-11-03\"\n## \n## $date_outcome\n## [1] NA\n## \n## $outcome\n## [1] NA\n## \n## $gender\n## [1] NA\n## \n## $age\n## [1] NA\n## \n## $age_unit\n## [1] NA\n## \n## $age_years\n## [1] NA\n## \n## $age_cat\n## [1] NA\n## \n## $age_cat5\n## [1] NA\n## \n## $hospital\n## [1] NA\n## \n## $lon\n## [1] -13.23381\n## \n## $lat\n## [1] 8.469638\n## \n## $infector\n## [1] NA\n## \n## $source\n## [1] NA\n## \n## $wt_kg\n## [1] 52.64487\n## \n## $ht_cm\n## [1] 124.9633\n## \n## $ct_blood\n## [1] 21.20686\n## \n## $fever\n## [1] NA\n## \n## $chills\n## [1] NA\n## \n## $cough\n## [1] NA\n## \n## $aches\n## [1] NA\n## \n## $vomit\n## [1] NA\n## \n## $temp\n## [1] NA\n## \n## $time_admission\n## [1] NA\n## \n## $bmi\n## [1] 46.89023\n## \n## $days_onset_hosp\n## [1] NA\nsafe_mean <- safely(mean)\nlinelist %>% \n  map(safe_mean)## $case_id\n## $case_id$result\n## [1] NA\n## \n## $case_id$error\n## NULL\n## \n## \n## $generation\n## $generation$result\n## [1] 16.56165\n## \n## $generation$error\n## NULL\n## \n## \n## $date_infection\n## $date_infection$result\n## [1] NA\n## \n## $date_infection$error\n## NULL\n## \n## \n## $date_onset\n## $date_onset$result\n## [1] NA\n## \n## $date_onset$error\n## NULL\n## \n## \n## $date_hospitalisation\n## $date_hospitalisation$result\n## [1] \"2014-11-03\"\n## \n## $date_hospitalisation$error\n## NULL\n## \n## \n## $date_outcome\n## $date_outcome$result\n## [1] NA\n## \n## $date_outcome$error\n## NULL\n## \n## \n## $outcome\n## $outcome$result\n## [1] NA\n## \n## $outcome$error\n## NULL\n## \n## \n## $gender\n## $gender$result\n## [1] NA\n## \n## $gender$error\n## NULL\n## \n## \n## $age\n## $age$result\n## [1] NA\n## \n## $age$error\n## NULL\n## \n## \n## $age_unit\n## $age_unit$result\n## [1] NA\n## \n## $age_unit$error\n## NULL\n## \n## \n## $age_years\n## $age_years$result\n## [1] NA\n## \n## $age_years$error\n## NULL\n## \n## \n## $age_cat\n## $age_cat$result\n## [1] NA\n## \n## $age_cat$error\n## NULL\n## \n## \n## $age_cat5\n## $age_cat5$result\n## [1] NA\n## \n## $age_cat5$error\n## NULL\n## \n## \n## $hospital\n## $hospital$result\n## [1] NA\n## \n## $hospital$error\n## NULL\n## \n## \n## $lon\n## $lon$result\n## [1] -13.23381\n## \n## $lon$error\n## NULL\n## \n## \n## $lat\n## $lat$result\n## [1] 8.469638\n## \n## $lat$error\n## NULL\n## \n## \n## $infector\n## $infector$result\n## [1] NA\n## \n## $infector$error\n## NULL\n## \n## \n## $source\n## $source$result\n## [1] NA\n## \n## $source$error\n## NULL\n## \n## \n## $wt_kg\n## $wt_kg$result\n## [1] 52.64487\n## \n## $wt_kg$error\n## NULL\n## \n## \n## $ht_cm\n## $ht_cm$result\n## [1] 124.9633\n## \n## $ht_cm$error\n## NULL\n## \n## \n## $ct_blood\n## $ct_blood$result\n## [1] 21.20686\n## \n## $ct_blood$error\n## NULL\n## \n## \n## $fever\n## $fever$result\n## [1] NA\n## \n## $fever$error\n## NULL\n## \n## \n## $chills\n## $chills$result\n## [1] NA\n## \n## $chills$error\n## NULL\n## \n## \n## $cough\n## $cough$result\n## [1] NA\n## \n## $cough$error\n## NULL\n## \n## \n## $aches\n## $aches$result\n## [1] NA\n## \n## $aches$error\n## NULL\n## \n## \n## $vomit\n## $vomit$result\n## [1] NA\n## \n## $vomit$error\n## NULL\n## \n## \n## $temp\n## $temp$result\n## [1] NA\n## \n## $temp$error\n## NULL\n## \n## \n## $time_admission\n## $time_admission$result\n## [1] NA\n## \n## $time_admission$error\n## NULL\n## \n## \n## $bmi\n## $bmi$result\n## [1] 46.89023\n## \n## $bmi$error\n## NULL\n## \n## \n## $days_onset_hosp\n## $days_onset_hosp$result\n## [1] NA\n## \n## $days_onset_hosp$error\n## NULL"},{"path":"writing-functions-1.html","id":"resources-36","chapter":"1 Escribir funciones","heading":"1.9 Recursos","text":"Funciones en R Data Science en españolCheatsheet advanzado de programación de RCheatsheet del paquete purrVídeo-ACM charla de Hadley Wickham: La alegría de la programación funcional (cómo funciona map_dbl)","code":""}]
